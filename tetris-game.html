<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tetris Game</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #181818;
      color: #fff;
      height: 100%;
      width: 100%;
      font-family: 'Segoe UI', sans-serif;
    }
    #tetris-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100vw;
      box-sizing: border-box;
    }
    #game-board {
      background: #222;
      border-radius: 12px;
      box-shadow: 0 4px 24px #0008;
      margin: 0 auto;
      display: block;
      touch-action: none;
    }
    #info-bar {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 400px;
      margin: 10px 0 20px 0;
    }
    .info-box {
      background: #222;
      padding: 10px 18px;
      border-radius: 5px;
      font-size: 1rem;
      text-align: center;
      margin: 0 5px;
      min-width: 80px;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      gap: 8px;
    }
    .control-btn {
      background: #333;
      color: #fff;
      font-size: 1.3rem;
      border: none;
      border-radius: 50%;
      margin: 0 2px;
      width: 54px;
      height: 54px;
      box-shadow: 0 2px 10px #0002;
      transition: background 0.2s;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
    }
    .control-btn:active {
      background: #555;
    }
    #btn-start {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 1rem;
      border-radius: 8px;
      border: none;
      background: #00bfff;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 2px 10px #0004;
      transition: background 0.2s;
    }
    #btn-start:hover {
      background: #0099cc;
    }
    @media (max-width: 500px) {
      #game-board { width: 90vw !important; height: 160vw !important; max-width: 99vw; }
      #info-bar { max-width: 98vw; font-size: 0.9rem; }
    }
  </style>
</head>
<body>
  <div id="tetris-container">
    <div id="info-bar">
      <div class="info-box" id="score">Score: 0</div>
      <div class="info-box" id="level">Level: 1</div>
      <div class="info-box" id="highscore">High: 0</div>
    </div>
    <canvas id="game-board" width="300" height="600"></canvas>
    <div id="controls">
      <button class="control-btn" id="btn-left" aria-label="Left">&#8592;</button>
      <button class="control-btn" id="btn-rotate" aria-label="Rotate">&#8635;</button>
      <button class="control-btn" id="btn-right" aria-label="Right">&#8594;</button>
      <button class="control-btn" id="btn-down" aria-label="Down">&#8595;</button>
      <button class="control-btn" id="btn-drop" aria-label="Drop">&#8681;</button>
      <button class="control-btn" id="btn-pause" aria-label="Pause">&#10073;&#10073;</button>
    </div>
    <!-- Start/Restart Button -->
    <button id="btn-start">Start Game</button>
  </div>
  <script>
    const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;
    const LEVEL_SPEED = [800, 700, 600, 500, 400, 300, 220, 160, 100, 60, 40];
    const SCORE_PER_LINE = [0, 100, 300, 500, 800];
    const SHAPES = [
      [[[1,1,1,1]], "#00bfff"], // I
      [[[1,1],[1,1]], "#ffd700"], // O
      [[[0,1,0],[1,1,1]], "#da70d6"], // T
      [[[0,1,1],[1,1,0]], "#7cfc00"], // S
      [[[1,1,0],[0,1,1]], "#ff4500"], // Z
      [[[1,0,0],[1,1,1]], "#ff69b4"], // J
      [[[0,0,1],[1,1,1]], "#8a2be2"]  // L
    ];

    let board, current, next, pos, score, lines, level, highscore;
    let paused, gameover, dropInterval;
    let lastTime = 0;

    function resetBoard() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));                              // Initialize the game board
    }

    function newPiece() {
      const id = Math.floor(Math.random() * SHAPES.length);                                       // Randomly select a shape
      return { 
        id: id,                                                                                   // Store the shape ID
        shape: SHAPES[id][0].map(row => [...row]),                                                // Clone the shape array
        color: SHAPES[id][1]                                                                      // Get the color associated with the shape
      };
    }

    function resetGame() {
      resetBoard();                                                                               // Reset the game board
      current = newPiece();                                                                       // Create a new piece
      next = newPiece();                                                                          // Create the next piece
      pos = {x: 3, y: 0};                                                                         // Set the initial position of the current piece
      score = 0;                                                                                  // Reset the score
      lines = 0;                                                                                  // Reset the number of cleared lines
      level = 1;                                                                                  // Reset the level
      paused = false;                                                                             // Reset the paused state                   
      gameover = false;                                                                           // Reset the game over state  
      dropInterval = LEVEL_SPEED[0];                                                              // Set the initial drop interval based on the level
      updateInfo();                                                                               // Update the displayed information 
      lastTime = 0;                                                                               // Reset the last time for the game loop
      requestAnimationFrame(loop);                                                                // Start the game loop
      draw();                                                                                     // Draw the initial game state
    }

    function updateInfo() {
      document.getElementById('score').textContent = 'Score: ' + score;                           // Update the score display 
      document.getElementById('level').textContent = 'Level: ' + level;                           // Update the level display
      document.getElementById('highscore').textContent = 'High: ' + (highscore || 0);             // Update the high score display
    }

    function drawBlock(ctx, x, y, color) {
      const size = window.BLOCK_SIZE || BLOCK_SIZE;                                               // Use the global BLOCK_SIZE or default to 30
      ctx.fillStyle = color;                                                                      // Set the fill color for the block 
      ctx.fillRect(x*size, y*size, size-1, size-1);                                               // Draw the block on the canvas
      ctx.strokeStyle = "#222";                                                                   // Set the stroke color for the block border
      ctx.lineWidth = 2;                                                                          // Set the line width for the border  
      ctx.strokeRect(x*size, y*size, size-1, size-1);                                             // Draw the border around the block
    }

    function draw() {
      const canvas = document.getElementById('game-board');                                       // Get the canvas element
      const ctx = canvas.getContext('2d');                                                        // Get the 2D rendering context
      ctx.clearRect(0,0,canvas.width,canvas.height);                                              // Clear the canvas
      for(let y=0; y<ROWS; ++y)                                                                    
        for(let x=0; x<COLS; ++x)                                                                 
          if(board[y][x])                                                                         // If the cell is occupied, draw the block
            drawBlock(ctx, x, y, board[y][x]);                                                    
      if(current)
        current.shape.forEach((row, dy) =>                                                        // Draw the current piece
          row.forEach((val, dx) => {                                                              // For each block in the piece
            if(val) drawBlock(ctx, pos.x+dx, pos.y+dy, current.color);                            // Draw each block of the current piece
          })
        );
    }

    function valid(offsetX=0, offsetY=0, newShape=null) {                                         
      const {shape} = current;                                                                    // Get the shape of the current piece
      const s = newShape || shape;                                                                // Use the new shape if provided, otherwise use the current shape 
      for(let y=0; y<s.length; ++y)                                                               
        for(let x=0; x<s[y].length; ++x)                                                          // Iterate through each block in the shape
          if(s[y][x]) {                                                                           // If the block is occupied
            let nx = pos.x + x + offsetX;                                                         // Calculate the new x position
            let ny = pos.y + y + offsetY;                                                         // Calculate the new y position
            if(nx<0 || nx>=COLS || ny<0 || ny>=ROWS) return false;                                // Check if the new position is out of bounds
            if(board[ny][nx]) return false;                                                       // Check if the new position collides with an existing block on the board
          }
      return true;
    }

    function merge() {                                                                            
      current.shape.forEach((row, dy) =>                                                           
        row.forEach((val, dx) => {                                                                // For each block in the current piece  
          if(val) board[pos.y+dy][pos.x+dx] = current.color;                                      // Merge the current piece into the board
        })
      );
    }

    function clearLines() {                                                                       
      let count = 0;                                                                               
      for(let y=ROWS-1; y>=0; --y) {                                                              // Check each row from the bottom up
        if(board[y].every(cell => cell)) {                                                        // If the row is completely filled
          board.splice(y, 1);                                                                     // Remove the filled row        
          board.unshift(Array(COLS).fill(0));                                                     // Add a new empty row at the top
          count++;                                                                                
          y++;                                                                                    // Adjust the index to account for the removed row
        }
      }
      if(count > 0) {
        score += SCORE_PER_LINE[count]*(level);                                                   // Update the score based on the number of lines cleared and the current level
        lines += count;                                                                           // Update the total number of lines cleared
        let newLevel = 1 + Math.floor(lines/10);                                                  // Calculate the new level based on the number of lines cleared
        if(newLevel > level) {                                                                    
          level = newLevel;                                                                       // Update the level if it has increased 
          dropInterval = LEVEL_SPEED[Math.min(level-1, LEVEL_SPEED.length-1)];                    // Update the drop interval based on the new level
        }
      }
    }

    function rotate() {
      const s = current.shape;                                                                     
      const rotated = s[0].map((_,i) => s.map(row => row[i]).reverse());                          // Rotate the shape 90 degrees clockwise
      if(valid(0,0,rotated))                                                                      
        current.shape = rotated;                                                                  // Update the current shape if the rotation is valid
    }

    function move(dx, dy) {                                                                       
      if(valid(dx, dy)) {                                                                         
        pos.x += dx;
        pos.y += dy;
        draw();
        return true;
      }
      return false;
    }

    function drop() {
      while(move(0,1));
      tick();
    }

    function tick() {
      if(!move(0,1)) {
        merge();
        clearLines();
        if(pos.y === 0) {
          gameover = true; 
          if(score > highscore) {
            highscore = score;
            localStorage.setItem('tetris-high', highscore);
          }
          updateInfo();
          draw();
          setTimeout(() => alert('Game Over!'), 100);
          return;
        }
        current = next;
        next = newPiece();
        pos = {x: 3, y: 0};
      }
      updateInfo();
    }

    function loop(time = 0) {
      if (paused || gameover) return;
      const delta = time - lastTime;
      if (delta > dropInterval) {
        tick();
        lastTime = time;
      }
      draw();
      requestAnimationFrame(loop);
    }

    function pauseGame() {
      paused = !paused;
      if(!paused) requestAnimationFrame(loop);
    }

    function handleKey(e) {
      if(gameover) return;
      if(e.repeat) return;
      switch(e.key) {
        case 'ArrowLeft': move(-1,0); break;
        case 'ArrowRight': move(1,0); break;
        case 'ArrowDown': move(0,1); break;
        case 'ArrowUp': rotate(); break;
        case ' ': drop(); break;
        case 'p': case 'P': pauseGame(); break;
        default: return;
      }
      draw();
    }

    function fitCanvas() {
      const canvas = document.getElementById('game-board');
      const maxWidth = Math.min(window.innerWidth * 0.98, 400);
      const maxHeight = Math.min(window.innerHeight * 0.80, 800);
      let size = Math.min(maxWidth/COLS, maxHeight/ROWS);
      size = Math.floor(size);
      canvas.width = size*COLS;
      canvas.height = size*ROWS;
      window.BLOCK_SIZE = size;
      draw();
    }

    // --- Controls ---
    document.getElementById('btn-left').onclick = () => { move(-1,0); };
    document.getElementById('btn-right').onclick = () => { move(1,0); };
    document.getElementById('btn-down').onclick = () => { move(0,1); };
    document.getElementById('btn-rotate').onclick = () => { rotate(); draw(); };
    document.getElementById('btn-drop').onclick = () => { drop(); };
    document.getElementById('btn-pause').onclick = () => { pauseGame(); };

    // Start/Restart button
    document.getElementById('btn-start').onclick = () => { resetGame(); };

    // Keyboard
    document.addEventListener('keydown', handleKey);

    highscore = Number(localStorage.getItem('tetris-high')) || 0;
    window.addEventListener('resize', fitCanvas);

    fitCanvas();
  </script>
</body>
</html>
